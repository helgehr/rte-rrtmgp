1c1
< program rte_rrtmgp_allsky
---
> program my_rte_rrtmgp_allsky
20a21,23
>   use mo_load_profiles,      only: load_profiles, load_vert_grid_info, load_2d_sw, load_2d_lw
>   use mo_gas_optics_constants,   only: grav
>   use mo_gas_optics_util_string, only: string_loc_in_array
26,27c29,31
<   real(wp), dimension(:,:),   allocatable :: p_lay, t_lay, p_lev, t_lev ! t_lev is only needed for LW
<   real(wp), dimension(:,:),   allocatable :: q, o3, col_dry
---
>   real(wp), dimension(:,:),   allocatable :: p_lay, t_lay, p_lev, t_lev, h_lev, dh_lev ! t_lev is only needed for LW
>   real(wp), dimension(:,:),   allocatable :: q, o3, col_dry, qc, qi, n2o, ch4
>   real(wp), dimension(:,:),   allocatable :: q_mmr, o3_mmr, qc_mmr, qi_mmr, n2o_mmr, ch4_mmr
33c37
<   real(wp), dimension(:),     allocatable :: t_sfc
---
>   real(wp), dimension(:),     allocatable :: t_sfc, solin
110a115,120
>   ! my vars
>   character(len=256) :: cs_mli_file, cs_grid_info_file
>   real(wp), dimension(:),   allocatable :: hyai, hybi, hyam, hybm, lwup, ps
>   real(wp), allocatable :: p0
>   real(wp), parameter :: sigma = 5.670374419e-8_wp ! Stefan-Boltzmann constant 
>   !----------
121c131
<   if (nUserArgs <  5) call stop_on_err("Usage: rrtmgp_allsky ncol nlay nreps output_file gas-optics [cloud-optics [aerosol-optics]]")
---
>   if (nUserArgs <  7) call stop_on_err("Usage: rrtmgp_allsky ncol nlay nreps output_file gas-optics climsim_lowres_grid_file climsim_mli_file [cloud-optics [aerosol-optics]]")
138,139c148,152
<   if (nUserArgs >= 6) then 
<     call get_command_argument(6,cloud_optics_file)
---
>   call get_command_argument(6,cs_grid_info_file)
>   call get_command_argument(7,cs_mli_file)
> 
>   if (nUserArgs >= 8) then 
>     call get_command_argument(8,cloud_optics_file)
142,143c155,156
<   if (nUserArgs >= 7) then 
<     call get_command_argument(7,aerosol_optics_file)
---
>   if (nUserArgs >= 9) then 
>     call get_command_argument(9,aerosol_optics_file)
146c159
<   if (nUserArgs >  7) print *, "Ignoring command line arguments beyond the first seven..."
---
>   if (nUserArgs >  9) print *, "Ignoring command line arguments beyond the first seven..."
148,149c161,163
<   allocate(p_lay(ncol, nlay), t_lay(ncol, nlay), p_lev(ncol, nlay+1), t_lev(ncol, nlay+1))
<   allocate(q    (ncol, nlay),    o3(ncol, nlay))
---
>   allocate(p_lay(ncol, nlay), t_lay(ncol, nlay), p_lev(ncol, nlay+1), t_lev(ncol, nlay+1), h_lev(ncol, nlay+1), dh_lev(ncol, nlay))
>   allocate(q    (ncol, nlay),    o3(ncol, nlay), qc   (ncol, nlay),   qi   (ncol, nlay), n2o(ncol, nlay), ch4(ncol, nlay), ps(ncol))
>   allocate(q_mmr(ncol, nlay),o3_mmr(ncol, nlay), qc_mmr(ncol, nlay), qi_mmr(ncol, nlay), n2o_mmr(ncol, nlay), ch4_mmr(ncol, nlay))
152c166,232
<   call compute_profiles(300._wp, ncol, nlay, p_lay, t_lay, p_lev, t_lev, q, o3)
---
>   ! ------------------- my stuff ------------------
>   ! cs_grid_info_file = "/p/scratch/icon-a-ml/heuer1/LEAP/ClimSim_low-res/ClimSim_low-res_grid-info.nc"
>   allocate(hyai(nlay+1), hybi(nlay+1), hyam(nlay), hybm(nlay), p0)
>   call load_vert_grid_info(cs_grid_info_file, ncol, nlay, hyai, hybi, hyam, hybm, p0)
>   ! print *, p0
>   ! print *, hyai
>   ! print *, hybi
>   ! print *, hyam
>   ! print *, hybm
>   ! print *, cs_grid_info_file
>   ! print *, cs_mli_file
> 
>   ! cs_mli_file = "/p/scratch/icon-a-ml/heuer1/LEAP/ClimSim_low-res/train/0001-02/E3SM-MMF.mli.0001-02-01-00000.nc"
>   call load_profiles(cs_mli_file,&
>                      ncol,&
>                      nlay,&
>                      nbnd,&
>                      hyai,&
>                      hybi,&
>                      hyam,&
>                      hybm,&
>                      p0,&
>                      ps,&
>                      p_lay,&
>                      t_lay,&
>                      p_lev,&
>                      q_mmr,&
>                      qc_mmr,&
>                      qi_mmr,&
>                      o3_mmr,&
>                      n2o_mmr,&
>                      ch4_mmr) 
>         
>   ! from https://www.weather.gov/media/epz/wxcalc/pressureAltitude.pdf
>   do ilay=1,nlay+1
>     do icol=1,ncol
>       h_lev(icol,ilay) = 0.3048_wp*145366.45_wp*(1 - (p_lev(icol,ilay)/ps(icol))**0.190284)
>     end do
>   end do
>   do ilay=1,nlay
>     do icol=1,ncol
>       dh_lev(icol,ilay) = h_lev(icol,ilay) - h_lev(icol,ilay+1)
>     end do
>   end do
>   ! print *, size(h_lev, 1)
>   ! print *, "------------"
>   ! print *, sum(h_lev, 1)/size(h_lev, 1)
>   ! print *, "------------"
>   ! print *, sum(dh_lev, 1)/size(dh_lev, 1)
>   ! print *, p_lay(192,:)
>   ! print *, "------------------"
>   ! print *, p_lev(192,:)
>   ! print *, "------------------"
>   ! print *, t_lay(192,:)
>   ! print *, "------------------"
>   
>   call get_gas_vmr(ncol, nlay, q_mmr, 'H2O', q)
>   call get_gas_vmr(ncol, nlay, qc_mmr, 'H2O', qc)
>   call get_gas_vmr(ncol, nlay, qi_mmr, 'H2O', qi)
>   call get_gas_vmr(ncol, nlay, o3_mmr, 'O3', o3)
>   call get_gas_vmr(ncol, nlay, n2o_mmr, 'N2O', n2o)
>   call get_gas_vmr(ncol, nlay, ch4_mmr, 'CH4', ch4)
>   ! ------------------- my stuff ------------------
>   ! call compute_profiles(300._wp, ncol, nlay, p_lay, t_lay, p_lev, t_lev, q, o3)
>   ! print *, p_lev(1,:)
>   ! print *, p_lay(1,:)
>   ! print *, (p_lev(1,1:60) + p_lev(1,2:61))*0.5
157,159c237,242
<   call stop_on_err(gas_concs%set_vmr("co2", 348.e-6_wp)) 
<   call stop_on_err(gas_concs%set_vmr("ch4", 1650.e-9_wp)) 
<   call stop_on_err(gas_concs%set_vmr("n2o", 306.e-9_wp)) 
---
>   call stop_on_err(gas_concs%set_vmr("co2", 388.717e-6_wp)) ! from &chem_surfvals_nl in atm_in (e3sm)
>   call stop_on_err(gas_concs%set_vmr("ch4", ch4)) 
>   call stop_on_err(gas_concs%set_vmr("n2o", n2o)) 
>   ! call stop_on_err(gas_concs%set_vmr("co2", 348.e-6_wp)) 
>   ! call stop_on_err(gas_concs%set_vmr("ch4", 1650.e-9_wp)) 
>   ! call stop_on_err(gas_concs%set_vmr("n2o", 306.e-9_wp)) 
192a276
>   ! print *,nbnd
219c303
<       call stop_on_err("rte_rrtmgp_allsky: Don't recognize the kind of optical properties ")
---
>       call stop_on_err("my_rte_rrtmgp_allsky: Don't recognize the kind of optical properties ")
228a313,332
>     allocate(sfc_alb_dir(nbnd, ncol), sfc_alb_dif(nbnd, ncol), mu0(ncol), solin(ncol))
>     call load_2d_sw(cs_mli_file,&
>                       ncol,&
>                       nlay,&
>                       nbnd,&
>                       k_dist%get_band_lims_wavenumber(),&
>                       solin,&
>                       mu0,&
>                       sfc_alb_dir,&
>                       sfc_alb_dif)
> 
>     ! print *, solin(192)
>     ! print *, "------------------"
>     ! print *, mu0(192)
>     ! print *, "------------------"
>     ! print *, sfc_alb_dir(:,192)
>     ! print *, "------------------"
>     ! print *, sfc_alb_dif(:,192)
>     ! print *, "------------------"
> 
231d334
<     allocate(sfc_alb_dir(nbnd, ncol), sfc_alb_dif(nbnd, ncol), mu0(ncol))
237,239c340,342
<     sfc_alb_dir = 0.06_wp
<     sfc_alb_dif = 0.06_wp
<     mu0 = .86_wp
---
>     ! sfc_alb_dir = 0.06_wp
>     ! sfc_alb_dif = 0.06_wp
>     ! mu0 = .86_wp
248c351,360
<     allocate(t_sfc(ncol), emis_sfc(nbnd, ncol))
---
>     allocate(t_sfc(ncol), emis_sfc(nbnd, ncol), lwup(ncol))
>     call load_2d_lw(cs_mli_file,&
>                       ncol,&
>                       nlay,&
>                       nbnd,&
>                       lwup)
>                     
>     ! print *, lwup(192)
>     ! print *, "------------------"
> 
254,255c366,373
<     t_sfc = t_lev(1, merge(nlay+1, 1, top_at_1))
<     emis_sfc = 0.98_wp
---
>     ! emis_sfc = 0.98_wp
>     ! Set to 1 instead after this note (to be discussed): https://github.com/E3SM-Project/ACME-ECP/blob/3912d6af813c80c6b7ca6264916cafc0a9e0069e/components/cam/src/physics/rrtmgp/radiation.F90#L1289-L1294
>     emis_sfc = 1.0_wp
> 
>     ! t_sfc = t_lev(1, merge(nlay+1, 1, top_at_1))
>     t_sfc = (lwup/(emis_sfc(1,:)*sigma))**(1.0/4.0)
>     ! print *, sum(t_sfc)/size(t_sfc)
> 
337d454
<       ! print *, k_dist%get_gpoint_bands()
342a460,465
>       ! rescale toa_flux
>       do icol = 1, ncol 
>         ! print *, solin(icol) / SUM(toa_flux(icol,:))
>         toa_flux(icol,:) = toa_flux(icol,:) * solin(icol) / SUM(toa_flux(icol,:))
>       end do
>       ! end rescale toa_flux
354a478,481
>       ! print *, maxval(fluxes%flux_up(:,:), 1)
>       ! print *, "------------------"
>       ! print *, maxval(fluxes%flux_dn(:,:), 1)
> 
447,539d573
<   subroutine compute_profiles(SST, ncol, nlay, p_lay, t_lay, p_lev, t_lev, q_lay, o3)
<     !
<     ! Construct profiles of pressure, temperature, humidity, and ozone 
<     !   more or less following the RCEMIP protocol for a surface temperature of 300K
<     !   more or less follows a Python implementation by Chiel van Heerwardeen
<     ! Extensions for future - variable SST and T profile, variable RH, lapse rate in stratosphere 
<     !   will all access absorption coefficient data more realistically 
<     !
<     real(wp),                          intent(in ) :: SST 
<     integer,                           intent(in ) :: ncol, nlay
<     real(wp), dimension(ncol, nlay  ), intent(out) :: p_lay, t_lay, q_lay, o3
<     real(wp), dimension(ncol, nlay+1), intent(out) :: p_lev, t_lev
< 
<     real(wp) :: z_lay(nlay), z_lev(nlay+1)
<     real(wp) :: z, q, T, p
<     real(wp) :: Tv, Tv0, p_hpa
<     integer  :: icol, ilay, i
< 
<     real(wp), parameter :: z_trop = 15000._wp, z_top = 70.e3_wp
<     ! Ozone profile - maybe only a single profile? 
<     real(wp), parameter :: g1 = 3.6478_wp, g2 = 0.83209_wp, g3 = 11.3515_wp, o3_min = 1e-13_wp 
<     ! According to CvH RRTMGP in Single Precision will fail with lower ozone concentrations
< 
<     real(wp), parameter :: g = 9.79764, Rd = 287.04, p0 = 101480. ! Surface pressure 
<     real(wp), parameter :: z_q1 = 4.0e3, z_q2 = 7.5e3,  q_t = 1.e-8
<     real(wp), parameter :: gamma = 6.7e-3
<     
<     real(wp), parameter :: q_0 = 0.01864 ! for 300 K SST.
<     ! -------------------
<     Tv0 = (1. + 0.608*q_0) * SST
<     !
<     ! Split resolution above and below RCE tropopause (15 km or about 125 hPa)
<     !
<     z_lev(:) = [0._wp,  2._wp*           z_trop /nlay * [(i, i=1, nlay/2)],  & 
<                z_trop + 2._wp * (z_top - z_trop)/nlay * [(i, i=1, nlay/2)]]
<     z_lay(:) = 0.5_wp * (z_lev(1:nlay)  + z_lev(2:nlay+1))
<     
<     !$acc        data copyin(z_lev, z_lay) 
<     !$omp target data map(to:z_lev, z_lay)
< 
<     !
<     ! The two loops are the same, except applied to layers and levels 
<     !   but nvfortran doesn't seems to support elemental procedures in OpenACC loops
<     !
<     !$acc                         parallel loop    collapse(2) 
<     !$omp target teams distribute parallel do simd collapse(2) 
<     do ilay = 1, nlay 
<       do icol = 1, ncol 
<         z = z_lay(ilay) 
<         if (z > z_trop) then 
<           q = q_t
<           T = SST - gamma*z_trop/(1. + 0.608*q_0)
<           Tv  = (1. + 0.608*q  ) *   T
<           p = p0 * (Tv/Tv0)**(g/(Rd*gamma)) * exp( -((g*(z-z_trop))/(Rd*Tv)) )
<         else 
<           q = q_0 * exp(-z/z_q1) * exp(-(z/z_q2)**2)
<           T = SST - gamma*z / (1. + 0.608*q)    
<           Tv  = (1. + 0.608*q  ) *   T
<           p = p0 * (Tv/Tv0)**(g/(Rd*gamma))
<         end if 
<         p_lay(icol,ilay) = p 
<         t_lay(icol,ilay) = T
<         q_lay(icol,ilay) = q
<         p_hpa = p_lay(icol,ilay) / 100._wp
<         o3(icol, ilay) = max(o3_min, & 
<                              g1 * p_hpa**g2 * exp(-p_hpa/g3) * 1.e-6_wp)
<       end do
<     end do 
< 
<     !$acc                         parallel loop    collapse(2) 
<     !$omp target teams distribute parallel do simd collapse(2) 
<     do ilay = 1, nlay+1
<       do icol = 1, ncol 
<         z = z_lev(ilay) 
<         if (z > z_trop) then 
<           q = q_t
<           T = SST - gamma*z_trop/(1. + 0.608*q_0)
<           Tv  = (1. + 0.608*q  ) *   T
<           p = p0 * (Tv/Tv0)**(g/(Rd*gamma)) * exp( -((g*(z-z_trop))/(Rd*Tv)) )
<         else 
<           q = q_0 * exp(-z/z_q1) * exp(-(z/z_q2)**2)
<           T = SST - gamma*z / (1. + 0.608*q)    
<           Tv  = (1. + 0.608*q  ) *   T
<           p = p0 * (Tv/Tv0)**(g/(Rd*gamma))
<         end if 
<         p_lev(icol,ilay) = p 
<         t_lev(icol,ilay) = T
<       end do 
<     end do 
<     !$acc end        data
<     !$omp end target data
<   end subroutine compute_profiles
<   ! ----------------------------------------------------------------------------------
553a588,611
>     ! for icon adaption
>     real(wp) :: reimin, reimax, relmin, relmax, re_cryst_scal, re_drop_scal, ziwc, zlwc, zkap, effective_radius
>     real(wp) :: mean_cdnc(60) = (/2.00000000e+07, 2.00000000e+07, 2.00000000e+07, 2.00000000e+07,&
>                   2.00000000e+07, 2.00000000e+07, 2.00000000e+07, 2.00000000e+07,&
>                   2.00000000e+07, 2.00000000e+07, 2.00000000e+07, 2.00000000e+07,&
>                   2.00000000e+07, 2.00000000e+07, 2.00000000e+07, 2.00000000e+07,&
>                   2.00000000e+07, 2.00000000e+07, 2.00000000e+07, 2.00000000e+07,&
>                   2.00000000e+07, 2.00000000e+07, 2.00000000e+07, 2.00000000e+07,&
>                   2.00000000e+07, 2.00000000e+07, 2.00000000e+07, 2.00000000e+07,&
>                   2.00000000e+07, 2.00000000e+07, 2.00000000e+07, 2.00000000e+07,&
>                   2.00000000e+07, 2.00000000e+07, 2.00000680e+07, 2.00023200e+07,&
>                   2.00295560e+07, 2.01922880e+07, 2.07834940e+07, 2.22821960e+07,&
>                   2.51960240e+07, 2.98459080e+07, 3.62477360e+07, 4.41368320e+07,&
>                   5.30814960e+07, 6.26067720e+07, 7.22813280e+07, 8.17591280e+07,&
>                   9.07884320e+07, 9.92019200e+07, 1.04135896e+08, 1.05483576e+08,&
>                   1.06020616e+08, 1.06287360e+08, 1.06438648e+08, 1.06539488e+08,&
>                   1.06609136e+08, 1.06655440e+08, 1.06689352e+08, 1.80468740e+07/)
>       ! adapted from ICON radiation code
>       real(wp), parameter :: droplet_scale = 1.0e2
>       real(wp), parameter :: pi = acos(-1._wp)
>       real(wp), parameter :: rhoh2o = 1000._wp
>       real(wp), parameter :: ccwmin = 1.e-7_wp      ! min condensate for lw cloud opacity
>       real(wp), parameter :: zkap_cont = 1.143_wp   ! continental (Martin et al. ) breadth param
>       real(wp), parameter :: zkap_mrtm = 1.077_wp    ! maritime (Martin et al.) breadth parameter
575c633
<         call stop_on_err("rte_rrtmgp_allsky: Don't recognize the kind of optical properties ")
---
>         call stop_on_err("my_rte_rrtmgp_allsky: Don't recognize the kind of optical properties ")
585,592c643,685
<     ! Restrict clouds to troposphere (> 100 hPa = 100*100 Pa)
<     !   and not very close to the ground (< 900 hPa), and
<     !   put them in 2/3 of the columns since that's roughly the
<     !   total cloudiness of earth
<     rel_val = 0.5 * (cloud_optics%get_min_radius_liq() + cloud_optics%get_max_radius_liq())
<     rei_val = 0.5 * (cloud_optics%get_min_radius_ice() + cloud_optics%get_max_radius_ice())
<     !$acc                         parallel loop    collapse(2) copyin(t_lay) copyout( lwp, iwp, rel, rei)
<     !$omp target teams distribute parallel do simd collapse(2) map(to:t_lay) map(from:lwp, iwp, rel, rei)
---
>     ! ----------------------------------- default method ------------------------------------ !
>     ! ! Restrict clouds to troposphere (> 100 hPa = 100*100 Pa)
>     ! !   and not very close to the ground (< 900 hPa), and
>     ! !   put them in 2/3 of the columns since that's roughly the
>     ! !   total cloudiness of earth
>     ! rel_val = 0.5 * (cloud_optics%get_min_radius_liq() + cloud_optics%get_max_radius_liq())
>     ! rei_val = 0.5 * (cloud_optics%get_min_radius_ice() + cloud_optics%get_max_radius_ice())
>     ! !$acc                         parallel loop    collapse(2) copyin(t_lay) copyout( lwp, iwp, rel, rei)
>     ! !$omp target teams distribute parallel do simd collapse(2) map(to:t_lay) map(from:lwp, iwp, rel, rei)
>     ! do ilay=1,nlay
>     !   do icol=1,ncol
>     !     cloud_mask(icol,ilay) = p_lay(icol,ilay) > 100._wp * 100._wp .and. &
>     !                             p_lay(icol,ilay) < 900._wp * 100._wp .and. &
>     !                             mod(icol, 3) /= 0
>     !     !
>     !     ! Ice and liquid will overlap in a few layers
>     !     !
>     !     ! lwp(icol,ilay) = merge(10._wp,  0._wp, cloud_mask(icol,ilay) .and. t_lay(icol,ilay) > 263._wp)
>     !     ! iwp(icol,ilay) = merge(10._wp,  0._wp, cloud_mask(icol,ilay) .and. t_lay(icol,ilay) < 273._wp)
> 
>     !     lwp(icol,ilay) = (p_lev(icol,ilay+1) - p_lev(icol,ilay)) * qc(icol,ilay) / grav * 1e3_wp
>     !     iwp(icol,ilay) = (p_lev(icol,ilay+1) - p_lev(icol,ilay)) * qi(icol,ilay) / grav * 1e3_wp
> 
>     !     rel(icol,ilay) = merge(rel_val, 0._wp, lwp(icol,ilay) > 0._wp)
>     !     rei(icol,ilay) = merge(rei_val, 0._wp, iwp(icol,ilay) > 0._wp)
> 
>     !   end do
>     ! end do
>     ! ----------------------------------- icon method ------------------------------------ !
>     effective_radius = &
>       1.0e6_wp * droplet_scale * (3.0e-9_wp / (4.0_wp * pi * rhoh2o))**(1.0_wp/3.0_wp) 
> 
>     reimin = cloud_optics%get_min_radius_ice()
>     reimax = cloud_optics%get_max_radius_ice()
>     
>     relmin = cloud_optics%get_min_radius_liq()
>     relmax = cloud_optics%get_max_radius_liq()
> 
>     IF (relmax <= relmin .OR. reimax <= reimin) THEN
>       CALL stop_on_err('compute_clouds: Droplet minimun size required is bigger than maximum')
>     END IF
> 
>     !$ACC parallel loop default(none) gang vector collapse(2) async(1)
595,597d687
<         cloud_mask(icol,ilay) = p_lay(icol,ilay) > 100._wp * 100._wp .and. &
<                                 p_lay(icol,ilay) < 900._wp * 100._wp .and. &
<                                 mod(icol, 3) /= 0
599c689
<         ! Ice and liquid will overlap in a few layers
---
>         ! --- Cloud liquid and ice mass: [kg/m2 in cell] --> [g/m2 in cloud]
601,606c691,729
<         lwp(icol,ilay) = merge(10._wp,  0._wp, cloud_mask(icol,ilay) .and. t_lay(icol,ilay) > 263._wp)
<         iwp(icol,ilay) = merge(10._wp,  0._wp, cloud_mask(icol,ilay) .and. t_lay(icol,ilay) < 273._wp)
<         rel(icol,ilay) = merge(rel_val, 0._wp, lwp(icol,ilay) > 0._wp)
<         rei(icol,ilay) = merge(rei_val, 0._wp, iwp(icol,ilay) > 0._wp)
<       end do
<     end do
---
>         ! cld_frc_loc = MAX(EPSILON(1.0_wp),cld_frc(icol,ilay))
>         ! ziwp(icol,ilay) = xm_ice(icol,ilay)*1000.0_wp/cld_frc_loc
>         ! zlwp(icol,ilay) = xm_liq(icol,ilay)*1000.0_wp/cld_frc_loc
> 
>         ! ! Mask which tells cloud optics that this cell is clear
>         ! lcldlyr = cld_frc(icol,ilay) > cld_frc_thresh !!!
>         ! IF (.NOT. lcldlyr) THEN
>         !   ziwp(icol,ilay) = 0.0_wp
>         !   zlwp(icol,ilay) = 0.0_wp
>         ! END IF
> 
>         lwp(icol,ilay) = (p_lev(icol,ilay+1) - p_lev(icol,ilay)) * qc(icol,ilay) / grav * 1e3_wp
>         iwp(icol,ilay) = (p_lev(icol,ilay+1) - p_lev(icol,ilay)) * qi(icol,ilay) / grav * 1e3_wp
>         !
>         ! --- cloud water and ice concentrations [g/m3]
>         !
>         ziwc = iwp(icol,ilay)/dh_lev(icol,ilay) !!!
>         zlwc = lwp(icol,ilay)/dh_lev(icol,ilay)
>         !
>         ! IF (lcldlyr .AND. (lwp(icol,ilay)+iwp(icol,ilay))>ccwmin) THEN
>         IF (lwp(icol,ilay)+iwp(icol,ilay) > ccwmin) THEN
> 
>           zkap = 0.71_wp*zkap_mrtm + 0.29_wp*zkap_cont
>           ! todo: extract land mask somehow
>           ! IF ( laland(icol) .AND. .NOT.laglac(icol) ) zkap = zkap_cont
>           
>           re_cryst_scal = MAX(reimin, MIN(reimax,83.8_wp*ziwc**0.216_wp))
>           re_drop_scal  = MAX(relmin, MIN(relmax, &
>             effective_radius * zkap * (zlwc / mean_cdnc(ilay))**(1.0_wp/3.0_wp) ))
> 
>           rei (icol,ilay) = re_cryst_scal
>           rel (icol,ilay) = re_drop_scal
>         ELSE
>           rei (icol,ilay) = reimin
>           rel (icol,ilay) = relmin
>         END IF
>       END DO
>     END DO
> 
636c759
<         call stop_on_err("rte_rrtmgp_allsky: Don't recognize the kind of optical properties ")
---
>         call stop_on_err("my_rte_rrtmgp_allsky: Don't recognize the kind of optical properties ")
652a776,779
>     if (do_aerosols) then
>       print *, "Clipping relhum to 0, 1 for aerosol computations"
>       relhum = min(max(relhum, 0._wp), 1._wp)
>     end if
789,791c916,919
<       if(nf90_def_dim(ncid, "gpt", ngpt, ngpt_dim) /= NF90_NOERR) &
<         call stop_on_err("rrtmgp_allsky: can't define ngpt dimension")
<       call create_var("toa_flux",    ncid, [col_dim, ngpt_dim])
---
>       ! print *, ngpt
>       ! if(nf90_def_dim(ncid, "gpt", ngpt, ngpt_dim) /= NF90_NOERR) &
>       !   call stop_on_err("rrtmgp_allsky: can't define ngpt dimension")
>       ! call create_var("toa_flux",    ncid, [col_dim, ngpt_dim])
833,835c961,963
<     if(is_sw) then
<       call stop_on_err(write_field(ncid, "toa_flux",  toa_flux))
<     end if
---
>     ! if(is_sw) then
>     !   call stop_on_err(write_field(ncid, "toa_flux",  toa_flux))
>     ! end if
863c991,1070
< end program rte_rrtmgp_allsky
---
>   subroutine get_gas_vmr(ncol, nlay, mmr, gas_name, vmr)
>   !from mmr to vmr (see https://github.com/E3SM-Project/ACME-ECP/blob/master/components/cam/src/physics/rrtmgp/radiation.F90)
> 
>       integer, intent(in ) :: ncol, nlay
>       character(len=*), intent(in) :: gas_name
>       real(wp), intent(in) :: mmr(ncol,nlay)
>       real(wp), intent(out) :: vmr(ncol,nlay)
> 
>       ! vmr = 1.0_wp
> 
>       ! Gases and molecular weights. Note that we do NOT have CFCs yet (I think
>       ! this is coming soon in RRTMGP). RRTMGP also allows for absorption due to
>       ! CO and N2, which RRTMG did not have.
>       character(len=3), dimension(8) :: gas_species = (/ &
>         'H2O', 'CO2', 'O3 ', 'N2O', &
>         'CO ', 'CH4', 'O2 ', 'N2 ' &
>       /)
>       real(wp), dimension(8) :: mol_weight_gas = (/ &
>         18.01528, 44.0095, 47.9982, 44.0128, &
>         28.0101, 16.04246, 31.998, 28.0134 &
>       /)  ! g/mol
> 
>       ! Molar weight of air
>       real(wp), parameter :: mol_weight_air = 28.97  ! g/mol
>                                       
>       ! Defaults for gases that are not available (TODO: is this still accurate?)
>       real(wp), parameter :: co_vmr = 1.0e-7_wp
>       real(wp), parameter :: n2_vmr = 0.7906_wp
> 
>       ! Loop indices
>       integer :: igas
> 
>       ! Name of routine
>       character(len=32) :: subname = 'get_gas_vmr'
> 
>       ! Get index into gas names we define above that we know the molecular 
>       ! weights for; if this gas is not in list of gases we know about, skip
>       igas = string_loc_in_array(gas_name, gas_species)
>       !igas = 1
>       if (igas <= 0) then
>         !call endrun('Gas name ' // trim(gas_name) // ' not recognized.')
>         call stop_on_err('Gas name ' // trim(gas_name) // ' not recognized.')
>       end if
>         
>       ! initialize
>       vmr(:,:) = 0._wp
> 
>       select case(trim(gas_species(igas)))
> 
>         case('CO')
> 
>            ! CO not available, use default
>            vmr(1:ncol,1:nlay) = co_vmr
> 
>         case('N2')
> 
>            ! N2 not available, use default
>            vmr(1:ncol,1:nlay) = n2_vmr
> 
>         case('H2O')
>            ! Convert to volume mixing ratio by multiplying by the ratio of
>            ! molecular weight of dry air to molecular weight of gas. Note that
>            ! first specific humidity (held in the mass_mix_ratio array read
>            ! from rad_constituents) is converted to an actual mass mixing
>            ! ratio.
>            vmr(1:ncol,1:nlay) = mmr(1:ncol,1:nlay) / ( &
>               1._wp - mmr(1:ncol,1:nlay) &
>            )  * mol_weight_air / mol_weight_gas(igas)
> 
>         case DEFAULT
> 
>            ! Convert to volume mixing ratio by multiplying by the ratio of
>            ! molecular weight of dry air to molecular weight of gas
>            vmr(1:ncol,1:nlay) = mmr(1:ncol,1:nlay) &
>                               * mol_weight_air / mol_weight_gas(igas)
> 
>       end select
> 
>    end subroutine get_gas_vmr
> end program my_rte_rrtmgp_allsky
